#R Code Masterarbeit Rekonstruktion einer übermoorten, prähistorischen Landschaft bei Wanna, Ldkr. Cuxhaven
#Kartierung Magnetik
#Setzen des Pfades des Arbeitsverzeichnisses
setwd("Z:/GIS")

#installieren des Package "rgdal", falls dieses noch nicht vorhanden ist
#BIVAND ET AL. 2021, https://CRAN.R-project.org/package=rgdal
#install.package("rgdal")
library(rgdal)


#installieren des Package "raster", falls dieses noch nicht vorhanden ist
#HIJMANS 2020, https://CRAN.R-project.org/package=raster
#install.package("raster")
library(raster)

#Bevor die Analysen durchgeführt werden können, muss sichergestellt sein, dass die 
#Funktionen des Packages "magAAR"
#installiert sind. Für die Bearbeitung der Abschlussarbeit wurden diese manuell installiert. 
#MENNENGA 2017b, https://github.com/ISAAKiel/magAAR

#In dem nächsten Schritt werden alle Magnetogramme sowie die markierten Anomalien #felderweise durchgegangen. 
#Es werden Dipole extrahiert und Anomalien nach größe kategorisiert 
#Da sich die Schritte wiederholen wird der erste Datensatz exemplarisch für gesamte Analyse beschrieben


#168_172
#Die Mittelpunkte der extrahierten Anomalien wird als .shp Datein in die Arbeitsoberfläche #von R geladen und in eine 
#Variable geschrieben
ano_168_172 <- readOGR("./derived/MAGNETIK/MAG_ANA/GR5NT/MARKANO/168-172_gr5_mark.shp")
ano_168_172

#Das Magnetogramm der dazugehörigen Fläche wird als .sdat Datei in die Arbeitsoberfläche #von R geladen und in eine
#Variable geschrieben
mag_168_172 <- raster("./raw/MAGNETIK/Fläche_168-172/sdat/Flaeche_168-172.sdat")

#Darstellung des Magnetogramms und der markierten Anomalien als Überprüfung
#Hierfür wird das Raster des Magnetogramms in eine neue Variable geschrieben
mag_disp_168_172 <- mag_168_172

#Das Raster wird auf min und max 5 nT beschränkt.
mag_disp_168_172[mag_disp_168_172 > 5] <- 5
mag_disp_168_172[mag_disp_168_172 < -5] <- -5
#Darstellung des Magnetogramms und der markierten Anomalien
plot(mag_disp_168_172)
points(test, pch = 21, bg ="red", col="black")

#In einem nächsten Schritt werden die Dipole markiert und rausgerechnet. Hierfür wird die #folgende Funktion verwendet, mit den entsprechenden Parametern, welche der Vignette #des Packages entnommen sind.
#Das Ergebnis wird in eine neue Variable geschrieben.
analyse_mag_168_172 <- analyseMagnetic(anomalies_sdf =  ano_168_172, magnetic_raster =  mag_168_172, get_dipol = TRUE, angle_steps = 10, searchradius = 2.5, dipolfactor = 2, dipol_minima = -8)

#Unter der Verwendung der folgenden Parameter ist es möglich mit der gleichen Funktion #Anomalien zu gruppieren. Die Parameter die hier verwendet werden, sind ausführlich in der #Vignette des Package beschrieben.
#Das Ergebnis wird in der Variable ergänzt.
analyse_mag_168_172 <- analyseMagnetic(anomalies_sdf = analyse_mag_168_172, magnetic_raster = mag_168_172, searchradius = 2, angle_steps = 10, get_profile_values = TRUE, method = "avg",cut_value = 10)

#Die ergänzten Informationen der Extraktion und der Gruppierung werden in einer neuen #.shp Datei exportiert, mit der in bsp. QGIS weitergearbeitet werden kann.
writeOGR(obj= analyse_mag_168_172, dsn = "derived", layer="analyse_mag_168_172", driver = "ESRI Shapefile")


#173
ano_173 <- readOGR("./derived/MAGNETIK/MAG_ANA/GR5NT/MARKANO/173_gr5_mark.shp")
ano_173

mag_173 <- raster("./raw/MAGNETIK/Fläche_173/sdat/Flaeche_173.sdat")
mag_disp_173 <- mag_173

mag_disp_173[mag_disp_173 > 5] <- 5
mag_disp_173[mag_disp_173 < -5] <- -5

plot(mag_disp_173)
points(ano_173, pch = 21, bg ="red", col="black")

analyse_mag_173 <- analyseMagnetic(anomalies_sdf =  ano_173, magnetic_raster =  mag_173, get_dipol = TRUE, angle_steps = 10, searchradius = 2.5, dipolfactor = 2, dipol_minima = -8)

analyse_mag_173 <- analyseMagnetic(anomalies_sdf = analyse_mag_173, magnetic_raster = mag_173, searchradius = 2, angle_steps = 10, get_profile_values = TRUE, method = "avg",cut_value = 10)

writeOGR(obj= analyse_mag_173, dsn = "derived", layer="analyse_mag_173", driver = "ESRI Shapefile")



#174
ano_174 <- readOGR("./derived/MAGNETIK/MAG_ANA/GR5NT/MARKANO/174_gr5_mark.shp")
ano_174

mag_174 <- raster("./raw/MAGNETIK/Fläche_174/sdat/Flaeche_174.sdat")
mag_disp_174 <- mag_174

mag_disp_174[mag_disp_174 > 5] <- 5
mag_disp_174[mag_disp_174 < -5] <- -5

plot(mag_disp_174)
points(ano_174, pch = 21, bg ="red", col="black")

analyse_mag_174 <- analyseMagnetic(anomalies_sdf =  ano_174, magnetic_raster =  mag_174, get_dipol = TRUE, angle_steps = 10, searchradius = 2.5, dipolfactor = 2, dipol_minima = -8)

analyse_mag_174 <- analyseMagnetic(anomalies_sdf = analyse_mag_174, magnetic_raster = mag_174, searchradius = 2, angle_steps = 10, get_profile_values = TRUE, method = "avg",cut_value = 10)

writeOGR(obj= analyse_mag_174, dsn = "derived", layer="analyse_mag_174", driver = "ESRI Shapefile")


#175_176
ano_175_176 <- readOGR("./derived/MAGNETIK/MAG_ANA/GR5NT/MARKANO/175-176_gr5_mark.shp")
ano_175_176

mag_175_176 <- raster("./raw/MAGNETIK/Fläche_175-176/sdat/Flaeche_175_176.sdat")
mag_disp_175_176 <- mag_175_176

mag_disp_175_176[mag_disp_175_176 > 5] <- 5
mag_disp_175_176[mag_disp_175_176 < -5] <- -5

plot(mag_disp_175_176)
points(ano_175_176, pch = 21, bg ="red", col="black")

analyse_mag_175_176 <- analyseMagnetic(anomalies_sdf =  ano_175_176, magnetic_raster =  mag_175_176, get_dipol = TRUE, angle_steps = 10, searchradius = 2.5, dipolfactor = 2, dipol_minima = -8)

analyse_mag_175_176 <- analyseMagnetic(anomalies_sdf = analyse_mag_175_176, magnetic_raster = mag_175_176, searchradius = 2, angle_steps = 10, get_profile_values = TRUE, method = "avg",cut_value = 10)

writeOGR(obj= analyse_mag_175_176, dsn = "derived", layer="analyse_mag_175_176", driver = "ESRI Shapefile")

#177_182
ano_177_182 <- readOGR("./derived/MAGNETIK/MAG_ANA/GR5NT/MARKANO/177-182_gr_umz.shp")
ano_177_182

mag_177_182 <- raster("./raw/MAGNETIK/Fläche_177-182/sdat/Flaeche_177-182.sdat")
mag_disp_177_182 <- mag_177_182

mag_disp_177_182[mag_disp_177_182 > 5] <- 5
mag_disp_177_182[mag_disp_177_182 < -5] <- -5

plot(mag_disp_177_182)
points(ano_177_182, pch = 21, bg ="red", col="black")

analyse_mag_177_182 <- analyseMagnetic(anomalies_sdf =  ano_177_182, magnetic_raster =  mag_177_182, get_dipol = TRUE, angle_steps = 10, searchradius = 2.5, dipolfactor = 2, dipol_minima = -8)

analyse_mag_177_182 <- analyseMagnetic(anomalies_sdf = analyse_mag_177_182, magnetic_raster = mag_177_182, searchradius = 2, angle_steps = 10, get_profile_values = TRUE, method = "avg",cut_value = 10)

writeOGR(obj= analyse_mag_177_182, dsn = "derived", layer="analyse_mag_177_182", driver = "ESRI Shapefile")


#183
ano_183 <- readOGR("./derived/MAGNETIK/MAG_ANA/GR5NT/MARKANO/183_gr5_mark.shp")
ano_183

mag_183 <- raster("./raw/MAGNETIK/Fläche_183/sdat/Flaeche_183.sdat")
mag_disp_183 <- mag_183

mag_disp_183[mag_disp_183 > 5] <- 5
mag_disp_183[mag_disp_183 < -5] <- -5

plot(mag_disp_183)
points(ano_183, pch = 21, bg ="red", col="black")

analyse_mag_183 <- analyseMagnetic(anomalies_sdf =  ano_183, magnetic_raster =  mag_183, get_dipol = TRUE, angle_steps = 10, searchradius = 2.5, dipolfactor = 2, dipol_minima = -8)

analyse_mag_183 <- analyseMagnetic(anomalies_sdf = analyse_mag_183, magnetic_raster = mag_183, searchradius = 2, angle_steps = 10, get_profile_values = TRUE, method = "avg",cut_value = 10)

writeOGR(obj= analyse_mag_183, dsn = "derived", layer="analyse_mag_183", driver = "ESRI Shapefile")

#184-187
ano_184_187 <- readOGR("./derived/MAGNETIK/MAG_ANA/GR5NT/MARKANO/184-187_gr5_mark.shp")
ano_184_187

mag_184_187 <- raster("./raw/MAGNETIK/Fläche_184-187/sdat/Flaeche_184_187.sdat")
mag_disp_184_187 <- mag_184_187

mag_disp_184_187[mag_disp_184_187 > 5] <- 5
mag_disp_184_187[mag_disp_184_187 < -5] <- -5

plot(mag_disp_184_187)
points(ano_184_187, pch = 21, bg ="red", col="black")

analyse_mag_184_187 <- analyseMagnetic(anomalies_sdf =  ano_184_187, magnetic_raster =  mag_184_187, get_dipol = TRUE, angle_steps = 10, searchradius = 2.5, dipolfactor = 2, dipol_minima = -8)

analyse_mag_184_187 <- analyseMagnetic(anomalies_sdf = analyse_mag_184_187, magnetic_raster = mag_184_187, searchradius = 2, angle_steps = 10, get_profile_values = TRUE, method = "avg",cut_value = 10)

writeOGR(obj= analyse_mag_184_187, dsn = "derived", layer="analyse_mag_184_187", driver = "ESRI Shapefile")


#185
ano_185 <- readOGR("./derived/MAGNETIK/MAG_ANA/GR5NT/MARKANO/185_gr5_mark.shp")
ano_185

mag_185 <- raster("./raw/MAGNETIK/Fläche_185/sdat/Flaeche_185.sdat")
mag_disp_185 <- mag_185

mag_disp_185[mag_disp_185 > 5] <- 5
mag_disp_185[mag_disp_185 < -5] <- -5

plot(mag_disp_185)
points(ano_185, pch = 21, bg ="red", col="black")

analyse_mag_185 <- analyseMagnetic(anomalies_sdf =  ano_185, magnetic_raster =  mag_185, get_dipol = TRUE, angle_steps = 10, searchradius = 2.5, dipolfactor = 2, dipol_minima = -8)

analyse_mag_185 <- analyseMagnetic(anomalies_sdf = analyse_mag_185, magnetic_raster = mag_185, searchradius = 2, angle_steps = 10, get_profile_values = TRUE, method = "avg",cut_value = 10)

writeOGR(obj= analyse_mag_185, dsn = "derived", layer="analyse_mag_185", driver = "ESRI Shapefile")

#188-191
ano_188_191 <- readOGR("./derived/MAGNETIK/MAG_ANA/GR5NT/MARKANO/188-191_gr5_mark.shp")
ano_188_191

mag_188_191 <- raster("./raw/MAGNETIK/Fläche_188-191/sdat/Flaeche_188-191.sdat")
mag_disp_188_191 <- mag_189_191

mag_disp_188_191[mag_disp_189_191 > 5] <- 5
mag_disp_188_191[mag_disp_189_191 < -5] <- -5

plot(mag_disp_188_191)
points(ano_188_191, pch = 21, bg ="red", col="black")

analyse_mag_188_191 <- analyseMagnetic(anomalies_sdf =  ano_188_191, magnetic_raster =  mag_188_191, get_dipol = TRUE, angle_steps = 10, searchradius = 2.5, dipolfactor = 2, dipol_minima = -8)

analyse_mag_188_191 <- analyseMagnetic(anomalies_sdf = analyse_mag_188_191, magnetic_raster = mag_188_191, searchradius = 2, angle_steps = 10, get_profile_values = TRUE, method = "avg",cut_value = 10)

writeOGR(obj= analyse_mag_188_191, dsn = "derived", layer="analyse_mag_188_191", driver = "ESRI Shapefile")


#192
ano_192 <- readOGR("./derived/MAGNETIK/MAG_ANA/GR5NT/MARKANO/192_gr5_mark.shp")
ano_192

mag_192 <- raster("./raw/MAGNETIK/Fläche_192/sdat/Flaeche_192.sdat")
mag_disp_192 <- mag_192

mag_disp_192[mag_disp_192 > 5] <- 5
mag_disp_192[mag_disp_192 < -5] <- -5

plot(mag_disp_192)
points(ano_192, pch = 21, bg ="red", col="black")

analyse_mag_192 <- analyseMagnetic(anomalies_sdf =  ano_192, magnetic_raster =  mag_192, get_dipol = TRUE, angle_steps = 10, searchradius = 2.5, dipolfactor = 2, dipol_minima = -8)

analyse_mag_192 <- analyseMagnetic(anomalies_sdf = analyse_mag_192, magnetic_raster = mag_192, searchradius = 2, angle_steps = 10, get_profile_values = TRUE, method = "avg",cut_value = 10)

writeOGR(obj= analyse_mag_192, dsn = "derived", layer="analyse_mag_192", driver = "ESRI Shapefile")

#193
ano_193 <- readOGR("./derived/MAGNETIK/MAG_ANA/GR5NT/MARKANO/193_gr5_mark.shp")
ano_193

mag_193 <- raster("./raw/MAGNETIK/Fläche_193/sdat/Flaeche_193.sdat")
mag_disp_193 <- mag_193

mag_disp_193[mag_disp_193 > 5] <- 5
mag_disp_193[mag_disp_193 < -5] <- -5

plot(mag_disp_193)
points(ano_193, pch = 21, bg ="red", col="black")

analyse_mag_193 <- analyseMagnetic(anomalies_sdf =  ano_193, magnetic_raster =  mag_193, get_dipol = TRUE, angle_steps = 10, searchradius = 2.5, dipolfactor = 2, dipol_minima = -8)

analyse_mag_193 <- analyseMagnetic(anomalies_sdf = analyse_mag_193, magnetic_raster = mag_193, searchradius = 2, angle_steps = 10, get_profile_values = TRUE, method = "avg",cut_value = 10)

writeOGR(obj= analyse_mag_193, dsn = "derived", layer="analyse_mag_193", driver = "ESRI Shapefile")


#194
ano_194 <- readOGR("./derived/MAGNETIK/MAG_ANA/GR5NT/MARKANO/194_gr5_mark.shp")
ano_194

mag_194 <- raster("./raw/MAGNETIK/Fläche_194/sdat/Flaeche_194.sdat")
mag_disp_194 <- mag_194

mag_disp_194[mag_disp_194 > 5] <- 5
mag_disp_194[mag_disp_194 < -5] <- -5

plot(mag_disp_194)
points(ano_194, pch = 21, bg ="red", col="black")

analyse_mag_194 <- analyseMagnetic(anomalies_sdf =  ano_194, magnetic_raster =  mag_194, get_dipol = TRUE, angle_steps = 10, searchradius = 2.5, dipolfactor = 2, dipol_minima = -8)

analyse_mag_194 <- analyseMagnetic(anomalies_sdf = analyse_mag_194, magnetic_raster = mag_194, searchradius = 2, angle_steps = 10, get_profile_values = TRUE, method = "avg",cut_value = 10)

writeOGR(obj= analyse_mag_194, dsn = "derived", layer="analyse_mag_194", driver = "ESRI Shapefile")

#195
ano_195 <- readOGR("./derived/MAGNETIK/MAG_ANA/GR5NT/MARKANO/195_gr5_mark.shp")
ano_195

mag_195 <- raster("./raw/MAGNETIK/Fläche_195/sdat/Flaeche_195.sdat")
mag_disp_195 <- mag_195

mag_disp_195[mag_disp_195 > 5] <- 5
mag_disp_195[mag_disp_195 < -5] <- -5

plot(mag_disp_195)
points(ano_195, pch = 21, bg ="red", col="black")

analyse_mag_195 <- analyseMagnetic(anomalies_sdf =  ano_195, magnetic_raster =  mag_195, get_dipol = TRUE, angle_steps = 10, searchradius = 2.5, dipolfactor = 2, dipol_minima = -8)

analyse_mag_195 <- analyseMagnetic(anomalies_sdf = analyse_mag_195, magnetic_raster = mag_195, searchradius = 2, angle_steps = 10, get_profile_values = TRUE, method = "avg",cut_value = 10)

writeOGR(obj= analyse_mag_195, dsn = "derived", layer="analyse_mag_195", driver = "ESRI Shapefile")


#196
ano_196 <- readOGR("./derived/MAGNETIK/MAG_ANA/GR5NT/MARKANO/196_gr5_mark.shp")
ano_196

mag_196 <- raster("./raw/MAGNETIK/Fläche_196/sdat/Flaeche_196.sdat")
mag_disp_196 <- mag_196

mag_disp_196[mag_disp_196 > 5] <- 5
mag_disp_196[mag_disp_196 < -5] <- -5

plot(mag_disp_196)
points(ano_196, pch = 21, bg ="red", col="black")

analyse_mag_196 <- analyseMagnetic(anomalies_sdf =  ano_196, magnetic_raster =  mag_196, get_dipol = TRUE, angle_steps = 10, searchradius = 2.5, dipolfactor = 2, dipol_minima = -8)

analyse_mag_196 <- analyseMagnetic(anomalies_sdf = analyse_mag_196, magnetic_raster = mag_196, searchradius = 2, angle_steps = 10, get_profile_values = TRUE, method = "avg",cut_value = 10)

writeOGR(obj= analyse_mag_196, dsn = "derived", layer="analyse_mag_196", driver = "ESRI Shapefile")

#197
ano_197 <- readOGR("./derived/MAGNETIK/MAG_ANA/GR5NT/MARKANO/197_gr5_mark.shp")
ano_197

mag_197 <- raster("./raw/MAGNETIK/Fläche_197/sdat/Flaeche_197.sdat")
mag_disp_197 <- mag_197

mag_disp_197[mag_disp_197 > 5] <- 5
mag_disp_197[mag_disp_197 < -5] <- -5

plot(mag_disp_197)
points(ano_197, pch = 21, bg ="red", col="black")

analyse_mag_197 <- analyseMagnetic(anomalies_sdf =  ano_197, magnetic_raster =  mag_197, get_dipol = TRUE, angle_steps = 10, searchradius = 2.5, dipolfactor = 2, dipol_minima = -8)

analyse_mag_197 <- analyseMagnetic(anomalies_sdf = analyse_mag_197, magnetic_raster = mag_197, searchradius = 2, angle_steps = 10, get_profile_values = TRUE, method = "avg",cut_value = 10)

writeOGR(obj= analyse_mag_197, dsn = "derived", layer="analyse_mag_197", driver = "ESRI Shapefile")


#198
ano_198 <- readOGR("./derived/MAGNETIK/MAG_ANA/GR5NT/MARKANO/198_gr5_mark.shp")
ano_198

mag_198 <- raster("./raw/MAGNETIK/Fläche_198/sdat/Flaeche_198.sdat")
mag_disp_198 <- mag_198

mag_disp_198[mag_disp_198 > 5] <- 5
mag_disp_198[mag_disp_198 < -5] <- -5

plot(mag_disp_198)
points(ano_198, pch = 21, bg ="red", col="black")

analyse_mag_198 <- analyseMagnetic(anomalies_sdf =  ano_198, magnetic_raster =  mag_198, get_dipol = TRUE, angle_steps = 10, searchradius = 2.5, dipolfactor = 2, dipol_minima = -8)

analyse_mag_198 <- analyseMagnetic(anomalies_sdf = analyse_mag_198, magnetic_raster = mag_198, searchradius = 2, angle_steps = 10, get_profile_values = TRUE, method = "avg",cut_value = 10)

writeOGR(obj= analyse_mag_198, dsn = "derived", layer="analyse_mag_198", driver = "ESRI Shapefile")
 
12.2.	“Elevation Interpolation, Validation and Visualization (“ElevIVV”)”
#Elevation Interpolation, Visualization and Validation
#Installieren der fehlenden Bibliotheken

list.of.packages <- c("ggplot2","gstat", "rayshader", "raster", "fields","reshape2","sp","tibble","tidyr","rgdal")

new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

#Für eine manuelle Anwendung die folgenden Pakete, welche benötigt werden

#installieren des Package "ggplot2", falls dieses noch nicht vorhanden ist
#WICKHAM et al. 2020, https://CRAN.R-project.org/package=ggplot2
#install.packages("ggplot2")
library(ggplot2)

#installieren des Package "gstat", falls dieses noch nicht vorhanden ist
#PEBESMA/GRAELER 2020, https://CRAN.R-project.org/package=gstat
#install.packages("gstat")
library(gstat)

#installieren des Package "rayshader", falls dieses noch nicht vorhanden ist
#MORGAN-WALL 2020, https://CRAN.R-project.org/package=rayshader
#install.packages("rayshader")
library(rayshader)

#installieren des Package "raster", falls dieses noch nicht vorhanden ist
#HIJMANS 2020, https://CRAN.R-project.org/package=raster
#install.packages("raster")
library(raster)

#installieren des Package "fields", falls dieses noch nicht vorhanden ist
#NYCHKA 2020, https://CRAN.R-project.org/package=fields
#install.packages("fields")
library(fields)

#installieren des Package "reshape2", falls dieses noch nicht vorhanden ist
#WICKHAM 2020a, https://CRAN.R-project.org/package=reshape2
#install.packages("reshape2")
library(reshape2)

#installieren des Package "sp", falls dieses noch nicht vorhanden ist
#PEBESMA/BIVAND 2021, https://CRAN.R-project.org/package=sp 
#install.packages("sp")
library(sp)

#installieren des Package "rgdal", falls dieses noch nicht vorhanden ist
#BIVAND ET AL. 2021, https://CRAN.R-project.org/package=rgdal
#installed.packages("rgdal")
library(rgdal)
#installieren des Package "tidyr", falls dieses noch nicht vorhanden ist
#Wickham 2021, https://CRAN.R-project.org/package=tidyr
#install.packages("tidyr")
library(tidyr)

#installieren des Package "rgdal", falls dieses noch nicht vorhanden ist
#MÜLLER 2021, https://CRAN.R-project.org/package=tibble 
#install.packages("tibble")
library(tibble)

#installieren des Package "rgdal", falls dieses noch nicht vorhanden ist
#WICKHAM 2020b, https://cran.r-project.org/web/packages/plyr/index.html
#install.packages("plyr")
library(plyr)
##Visualisierung
#die Funktion plot.model() ist dazu geeignet, ein Raster eines Geländereliefs (digitales 
#Geländemodell oder interpolierte Geländeoberfläche) zwei dimensional sowie 
#perspektivisch darzustellen (ist vis = TRUE, so wird eine perspektivische Darstellung 
#erstellt)

plot.model <- function(title,rast,pts, vis = TRUE){
  
  if(vis == TRUE){
    
    rast_p <- rasterToPoints(rast)
    rast_df <- data.frame(rast_p)
    colnames(rast_df) <- c("xcoord", "ycoord", "zcoord")
    
    plot_rast<- ggplot(rast_df, aes(x=xcoord, y=ycoord))+
      geom_raster(aes(fill = zcoord ))+
      coord_equal()+
      ggtitle(title)+
      scale_fill_gradientn(na.value = "white",
                           colours = hcl.colors(10,
                                                palette = "Earth",
                                                rev = TRUE))+
      theme(axis.title.x = element_text(size=10),
            axis.title.y = element_text(size=10, angle=90),
            axis.text.x = element_text(size=8),
            axis.text.y = element_text(size=8, angle=90, vjust=0, hjust=0.5),
            panel.grid.major = element_blank(),
            panel.grid.minor = element_blank(),
            legend.position = "right",
            legend.key = element_blank())+
      geom_contour(aes(z=zcoord),colour = "grey",size = 0.2)+
      geom_point(aes(x=xcoord, y=ycoord), data = pts, size = 0.1)

    #Die Abbildung wird als .png Datei expoertiert
    ggsave(paste(title, ".png", sep=""), plot = plot_rast)
    

    #Erstellen einer perspektivischen Ansicht

    gg_rast <- ggplot(rast_df, aes(x=xcoord, y=ycoord))+
      geom_raster(aes(fill = zcoord ),show.legend =FALSE,hjust = 0,
                  vjust = 0)+
      coord_equal()+
      scale_y_continuous(position = "right") +
      scale_fill_gradientn(na.value = "white",
                           colours = hcl.colors(10,
                                                palette = "Earth",
                                                rev = TRUE))+
      theme(axis.title.x = element_text(size=10),
            axis.title.y = element_text(size=10, angle=90),
            axis.text.x = element_text(size=8),
            axis.text.y = element_text(size=8, angle=90, vjust=0, hjust=0.5),
            panel.grid.major = element_blank(),
            panel.grid.minor = element_blank())
    
#Mit der Funktion plot_gg() lässt sich eine perspektivische Darstellung eines „ggplots“ 
#erstellen und als .png Dateien exportieren

    rayshader::plot_gg(gg_rast,
                       multicore = TRUE,
                       raytrace = TRUE,
                       width = 3.5,
                       height = 4,
                       scale = 300,
                       windowsize = c(1100, 800),
                       zoom = 0.6,
                       phi = 30,
                       theta = 30,
                       background="white")
    render_snapshot(filename = paste(title, "_3D.png", sep=""), clear = TRUE)
    }
  else{
    rast_p <- rasterToPoints(rast)
    rast_df <- data.frame(rast_p)
    colnames(rast_df) <- c("xcoord", "ycoord", "zcoord ")
    plot_rast<- ggplot(rast_df, aes(x=xcoord, y=ycoord))+
      geom_raster(aes(fill = zcoord ))+
      coord_equal()+
      ggtitle(title)+
      scale_fill_gradientn(na.value = "white",
                           colours = hcl.colors(10,
                                                palette = "Earth",
                                                rev = TRUE))+
      theme(axis.title.x = element_text(size=10),
            axis.title.y = element_text(size=10, angle=90),
            axis.text.x = element_text(size=8),
            axis.text.y = element_text(size=8, angle=90, vjust=0, hjust=0.5),
            panel.grid.major = element_blank(),
            panel.grid.minor = element_blank(),
            legend.position = "right",
            legend.key = element_blank())+
      geom_contour(aes(z=zcoord),colour = "grey",size = 0.2)+
      geom_point(aes(x=xcoord, y=ycoord), data = pts, size = 0.1)
 #Die Abbildung wird als .png Datei expoertiert
    ggsave(paste(title, ".png", sep=""), plot = plot_rast)   
  }
  return(plot_rast)}

##Funktionen der räumlichen Interpolationsmethoden

#Distanzgewichtete Interpolationsverfahren

#mit der Funktion interp.idw.nn() ist es möglich nach zwei Verfahren zu interpolieren, Inverse
#Distance Weighted und Nearest Neighbour Interpolation

interp.idw.nn <- function(pts_spdf, attribut, rast){
    
#es wird eine Abfrage erstellt, in der der Benutzer den Wert der zu 
#betrachtenden Nachbarn eintragen kann

while(TRUE){
        nmax = suppressWarnings(as.numeric(readline("amount of nearest 
neighbour to include in interpolation: ")))
    
    if(!is.na(nmax)){
      
      break
    }   
  }
  
#es wird eine Abfrage erstellt, in der der Benutzer den Wert der zu 
#der Inverse Distance Power eintragen kann
  
  while(TRUE){   
    idp = suppressWarnings(as.numeric(readline("value for the inverse distance power: ")))
    
    if(!is.na(idp)){
      
      break
    }   
  }
  
#auf der Grundlage der durch den Benutzer gewählten Parameter wird nun die Interpolation 
#durchgeführt und in eine Variable übertragen, welche das berechnete Raster enthält

  idw_nn_model <- gstat(formula= attribut~1, data = pts_spdf, nmax=nmax , set=list(idp = idp))
  interp_idw_nn <- interpolate(rast, idw_nn_model)
   return(interp_idw_nn)}
#Geostatistische Verfahren

#mit der Funktion vario() lassen sich die Variogrammwolke, das Empirische Variogramm so
#wie die Anpassung von vier ausgewählten theoretischen Variogrammfunktionen, welche
#häufig für die Interpolation von Geländemodellen verwendet werden, berechnen. 

vario <- function(pts_spdf,attribut){

#Berechnung der Variogrammwolke  
  vc <- variogram(attribut~1,pts_spdf, cloud = TRUE)

#Berechnung des Empirischen Variogramms  
  ev <- variogram(attribut~1,pts_spdf)
  
#Anpassung einer Bessel Funktion an den Verlauf des Empirischen Variogramms  
  variofit_bes <- fit.variogram(
    object = ev,
    model = vgm(model = "Bes"),fit.sills = TRUE, fit.ranges = TRUE)
  
  bes <- plot(ev,variofit_bes,main="Bes")
  
#Anpassung einer Linear Funktion an den Verlauf des Empirischen Variogramms  
  variofit_lin <- fit.variogram(
    object = ev,
    model = vgm(model = "Lin"),fit.sills = TRUE, fit.ranges = TRUE)
  
  lin <- plot(ev,variofit_lin,main="Lin")
  
#Anpassung einer Spcherical Funktion an den Verlauf des Empirischen Variogramms    
  variofit_sph <- fit.variogram(
    object = ev,
    model = vgm(model = "Sph"),fit.sills = TRUE, fit.ranges = TRUE)
  
  sph <- plot(ev,variofit_sph,main="Sph")

#Anpassung einer Gaussian Funktion an den Verlauf des Empirischen Variogramms      
  variofit_gau <- fit.variogram(
    object = ev,
    model = vgm(model = "Gau"),fit.sills = TRUE, fit.ranges = TRUE)
  
  gau <- plot(ev,variofit_gau,main="Gau")  
  
  return(list(plot(vc),plot(ev),bes,lin,sph,gau))
}







#Simple Kriging Funktion
interp.sikri <- function(pts_spdf,attribut,rast,vgm){
  
#Berechnung des Variogramms  
  ev <- variogram(attribut~1,pts_spdf)  
  variofit <- fit.variogram(
    object = ev,
    model = vgm(model = vgm),fit.sills = TRUE, fit.ranges = TRUE)

#Konvertierung des Rasters in einen SpatialGridDataFrame  
  rast_sgdf <- as(rast, 'SpatialGridDataFrame')

#Berechnung des kriging means  
  beta = mean(attribut,digits = 2)
  beta <- round(beta, digit= 2)

#Errechnung einen Höhenmodells basierend auf dem Variogramm und kriging mean  
  interp_sikri <- krige(attribut~1, pts_spdf, rast_sgdf, variofit, beta = beta)    
  interp_sikri <- raster(interp_sikri)    
  return(interp_sikri)
}

#Ordinary Kriging Funktion
interp.orkri <- function(pts_spdf,attribut,rast,vgm){

#Berechnung des Variogramms    
  ev <- variogram(attribut~1,pts_spdf)  
  variofit <- fit.variogram(
    object = ev,
    model = vgm(model = vgm),fit.sills = TRUE, fit.ranges = TRUE)
  
#Konvertierung des Rasters in einen SpatialGridDataFrame    
  rast_sgdf <- as(rast, 'SpatialGridDataFrame')
  
#Errechnung einen Höhenmodells basierend auf dem Variogramm  
  interp_orkri <- krige(attribut~1, pts_spdf, rast_sgdf, variofit)    
  interp_orkri <- raster(interp_orkri)    
  return(interp_orkri)
}

#Spline Interpolation

#Thin Plated Spline Funktion
interp.tps <- function(pts_spdf,attribut ,rast){
#Berechnung eines Höhenmodells basierend auf Thine Plated Splines  
  tps_model <- Tps(coordinates(pts_spdf), attribut)
  
  interp_tps <- interpolate(rast, tps_model)
  
  return(interp_tps)
}
##Validierung

#Generierung der Stichprobenpunkte
valid.pts <- function(rast){  
  rast_sgdf <- as(rast, 'SpatialGridDataFrame')  
  sp <- data.frame(spsample(x = rast_sgdf, n =  10000, type = "stratified"))  
  return(sp) }

#Funktion für die Berechnung der Differenz 
valid.diff <- function(interpname, interprast,rast, valid.pts){
  gok_rast <- raster::extract(rast, valid.pts)
  gok_interprast <- raster::extract(interprast, valid.pts)    
  diff_gok_interprast_rast <- gok_interprast - gok_rast    
  diff_interprast_rast <- cbind(valid.pts,diff_gok_interprast_rast)  
  diff_interprast_rast <- diff_interprast_rast %>% drop_na()  
  colnames(diff_interprast_rast) <- c("xcoord","ycoord",interpname)  
  return(diff_interprast_rast) }

#Funktion für die Berechnung der Präzision 
valid.prec <- function(valid.value, tolmin, tolmax){
    prec <- sum(valid.value > tolmin & valid.value < tolmax) }

#Funktion für die Erstellung eines Abweichungsmodells
valid.model <- function(pts, interpname,diff_interp_rast,valid_value,rast){  
  coordinates(diff_interp_rast) <- ~xcoord+ycoord  
  proj4string(diff_interp_rast) <- proj4string(rast)  
  model_diff_nn <- gstat(formula= valid_value~1, data = diff_interp_rast, nmax=5, set=list(idp = 0))  
  model_diff <- interpolate(rast, model_diff_nn)
   model_diff_p <- rasterToPoints(model_diff)  
  model_diff_p_df <- data.frame(model_diff_p)  
  colnames(model_diff_p_df) <- c("xcoord", "ycoord", "deviation")   
  #low="blue", mid="white", high="red"  
  plot_diff <- ggplot(model_diff_p_df, aes(x=xcoord, y=ycoord))+
    geom_raster(aes(fill = deviation))+
    coord_equal()+
    scale_fill_gradient2(midpoint = 0, low="blue", mid="white", high="red",
          breaks = c(-1,-0.5,0,0.5,1), labels = format(c("-1","-0.5","0","0.5","1")), space = "Lab")+
    labs(title = interpname,
         subtitle = "deviation in m")+
    theme(axis.title.x = element_text(size=10),
          axis.title.y = element_text(size=10, angle=90),
          axis.text.x = element_text(size=8),
          axis.text.y = element_text(size=8, angle=90, vjust=0, hjust=0.5),
          legend.position = "right",
          legend.key = element_blank())+
    geom_point(aes(x=xcoord, y=ycoord), data = pts, size = 0.1)
  ggsave(paste(interpname, ".png", sep=""), plot = plot_diff)    
  return(plot_diff) }


#Berechnung eines Boxplots basierend auf der Differenz
valid.boxplot <- function(valid.diff){   
  boxplot <- reshape2::melt(valid.diff,c('id','Interpolationsverfahren'))  
  boxplot <- data_frame(Differenz = boxplot$value, Interpolationsverfahren = boxplot$Interpolationsverfahren,) %>%
    ggplot(., aes(x=Differenz,y=Interpolationsverfahren,fill=Differenz)) +
    ggtitle("Abweichung der interpolierten Werte")+
    xlab("Differenz in (m)")+
    ylab("Interpolationsverfahren")+
    geom_boxplot()+
    coord_flip()  
  return(boxplot)
}

 
#	Validierung anhand eines exemplarischen Datensatzes 

#Zunächst wird der bearbeitete Datensatz mit den Bohrungen in den R Workspace geladen, 
#um diesen auf seine Werte zu prüfen, um einen exemplarischen Datensatz auszuwählen, 
#anhand dessen die Validierung des Interpolationsverfahren durchgeführt werden kann

#In dem folgenden Abschnitt werden die XYZ Koordinaten der exemplarischen Bohrraster 
#.csv Datei in die R Arbeitsoberfläche importiert und zu einem DataFrame konvertiert,
#Des Weiteren werden die Bezeichnungen der Spalten für das Nutzen der Funktionen ent
#sprechend angepasst.

ExBP <- read.csv("./raw_data/ExBohrrasterXYZ.csv", header=TRUE, sep=";",dec=".")

colnames(ExBP) <- c("ID","zcoord","xcoord","ycoord")

write.table(ExBP, file = "ExBP.txt", sep = " ", dec=".", col.names = TRUE, row.names = FALSE)

#Um aus dem DataFrame ein räumliches Objekt ("spatial object") erstellen zu können, müs
#sen zunächst mit der Funktion coordinates() die Spalten festgelegt werden, aus denen die 
#räumlichen Koordinaten genommen werden

ExBP_spdf <- ExBP

coordinates(ExBP_spdf) <- ~xcoord+ycoord

ExBP_spdf

#Nach der Erstellung lässt sich mit der Funktion proj4string() die Projektion eines räumlichen 
#Datensatzes konfigurieren.

proj4string(ExBP_spdf) <- "+init=EPSG:25833 +proj=utm +zone=33 +datum=WGS84 +ellps=WGS84 +units=m +no_defs"

#In einem nächsten Schritt wird das digitale Geländemodell (DGM) für das exemplarische 
#Untersuchungsgebiet in die R Arbeitsoberfläche importiert. In einem nächsten Schritt
#wird ebenfalls die Projektion konfiguriert.

ExDEM <- raster("./raw_data/ExDEM.tif")

#"+init=EPSG:25833 +proj=utm +zone=33 +datum=WGS84 +ellps=WGS84 +units=m +no_defs"

proj4string(ExDEM) <- "+init=EPSG:25833 +proj=utm +zone=33 +datum=WGS84 +ellps=WGS84 +units=m +no_defs"





#Für die Analyse der Interpolationsverfahren ist es notwendig, dass das DGM auf die 
#räumlichen Ausmaße des Bohrrasters zurechtgeschnitten wird.

ExDEM_crop <- crop(ExDEM, ExBP_spdf)

proj4string(ExDEM_crop) <- "+init=EPSG:25833 +proj=utm +zone=33 +datum=WGS84 +ellps=WGS84 +units=m +no_defs"

#Über die Verwendung von plot.model() wird das DGM visualisiert
plot.model("Digital Elevation Model",ExDEM_crop,ExBP,vis = TRUE)

## Interpolation

#Distanzgewichtete Interpolationsverfahren

#Inverse Distance Weighted (idp = 2)
idw2 <- interp.idw.nn(ExBP_spdf, ExBP_spdf@data$zcoord,ExDEM_crop)
plot.model("Inverse Distance Weighted (idp = 2)", idw2,ExBP,vis =TRUE)
writeRaster(idw2,"Inverse Distance Weighted (idp = 2)",format="GTiff")

#Inverse Distance Weighted (idp = 3)
idw3 <- interp.idw.nn(ExBP_spdf, ExBP_spdf@data$zcoord,ExDEM_crop)
plot.model("Inverse Distance Weighted (idp = 3)", idw3,ExBP,vis =TRUE)
writeRaster(idw3,"Inverse Distance Weighted (idp = 3)",format="GTiff")

#Inverse Distance Weighted (idp = 4)
idw4 <- interp.idw.nn(ExBP_spdf, ExBP_spdf@data$zcoord,ExDEM_crop)
plot.model("Inverse Distance Weighted (idp = 4)", idw4,ExBP,vis =TRUE)
writeRaster(idw4,"Inverse Distance Weighted (idp = 4)",format="GTiff")

#Nearest Neighbour (nmax = 4)
nn4 <- interp.idw.nn(ExBP_spdf, ExBP_spdf@data$zcoord,ExDEM_crop)
plot.model("Nearest Neighbour (nmax = 4)", nn4,ExBP,vis =TRUE)
writeRaster(nn4,"Nearest Neighbour (nmax = 4)",format="GTiff")

#Nearest Neighbour (nmax = 5)
nn5 <- interp.idw.nn(ExBP_spdf, ExBP_spdf@data$zcoord,ExDEM_crop)
plot.model("Nearest Neighbour (nmax = 5)", nn5,ExBP,vis =TRUE)
writeRaster(nn5,"Nearest Neighbour (nmax = 5)",format="GTiff")

#Nearest Neighbour (nmax = 6)
nn6 <- interp.idw.nn(ExBP_spdf, ExBP_spdf@data$zcoord,ExDEM_crop)
plot.model("Nearest Neighbour (nmax = 6)", nn6,ExBP,vis =TRUE)
writeRaster(nn6,"Nearest Neighbour (nmax = 6)",format="GTiff")

#Inverse Distance Weighted (idp = 2, nmax = 5)
idw2_nn5 <- interp.idw.nn(ExBP_spdf, ExBP_spdf@data$zcoord,ExDEM_crop)
plot.model("Inverse Distance Weighted (nmax = 5, idp = 2)", idw2_nn5,ExBP,vis =TRUE)
writeRaster(idw2_nn5,"Inverse Distance Weighted (nmax = 5, idp = 2)",format="GTiff")


#Inverse Distance Weighted (idp = 3, nmax = 5)
idw3_nn5 <- interp.idw.nn(ExBP_spdf, ExBP_spdf@data$zcoord,ExDEM_crop)
plot.model("Inverse Distance Weighted (nmax = 5, idp = 3)", idw3_nn5,ExBP,vis =TRUE)
writeRaster(idw3_nn5,"Inverse Distance Weighted (nmax = 5, idp = 3)",format="GTiff")

#Inverse Distance Weighted (idp = 4, nmax = 5)
idw4_nn5 <- interp.idw.nn(ExBP_spdf, ExBP_spdf@data$zcoord,ExDEM_crop)
plot.model("Inverse Distance Weighted (nmax = 5, idp = 4)", idw4_nn5,ExBP,vis =TRUE)
writeRaster(idw4_nn5,"Inverse Distance Weighted (nmax = 5, idp = 4)",format="GTiff")


#Geostatistische Verfahren

#Darstellung der theoretischen Variogrammfunktionen
show.vgms()

#Erstellung von Variogrammwolke, Empirischem Variogramm und vier an das Empirische 
#Variogramm angepasste, theoretische Variogrammfunktionen
vario(ExBP_spdf, ExBP_spdf@data$zcoord)

#Simpel Kriging (vgm = Bes)
sikribes <- interp.sikri(ExBP_spdf, ExBP_spdf@data$zcoord, ExDEM_crop,vgm = "Bes")

#Simpel Kriging (vgm = Sph)
sikrisph <- interp.sikri(ExBP_spdf, ExBP_spdf@data$zcoord, ExDEM_crop,vgm = "Sph")

#Ordinary Kriging (vgm = Bes)
orkribes <- interp.orkri(ExBP_spdf, ExBP_spdf@data$zcoord, ExDEM_crop,vgm = "Bes")

#Ordinary Kriging (vgm = Sph)
orkrisph <- interp.orkri(ExBP_spdf, ExBP_spdf@data$zcoord, ExDEM_crop,vgm = "Sph")

#Spline Interpolation

#Thin Plated Spline
tps <- interp.tps(ExBP_spdf, ExBP_spdf@data$zcoord,ExDEM_crop)
plot.model("Thin Plated Spline", tps,ExBP,vis =TRUE)
writeRaster(tps,"Thin Plated Spline",format="GTiff")

#Import des Rasters interpoliert nach Thin Plated Spline (TIN)
tps_tin <- raster("./raw_data/TPS_TIN.tif")
tps_tin <- crop(tps_tin, ExBP_spdf)
plot.model("Thin Plated Spline (TIN)", tps_tin,ExBP,vis =TRUE)








##Validierung

#Berechnung der Stichprobenpunkte
vpts <- valid.pts.mdl(ExDEM_crop)

#Berechnung der Differenz
IDW2_valid <- valid.diff(interpname = "IDW2", interprast = idw2, valid.pts = vpts, rast = ExDEM_crop)
IDW3_valid <- valid.diff(interpname = "IDW3", interprast = idw3, valid.pts = vpts, rast = ExDEM_crop)
IDW4_valid <- valid.diff(interpname = "IDW4", interprast = idw4, valid.pts = vpts, rast = ExDEM_crop)
NNI4_valid <- valid.diff(interpname = "NNI4", interprast = nn4, valid.pts = vpts, rast = ExDEM_crop)
NNI5_valid <- valid.diff(interpname = "NNI5", interprast = nn5, valid.pts = vpts, rast = ExDEM_crop)
NNI6_valid <- valid.diff(interpname = "NNI6", interprast = nn6, valid.pts = vpts, rast = ExDEM_crop)
IDW2_NN5_valid <- valid.diff(interpname = "IDW2_NN5", interprast = idw2_nn5, valid.pts = vpts, rast = ExDEM_crop)
IDW3_NN5_valid <- valid.diff(interpname = "IDW3_NN5", interprast = idw3_nn5, valid.pts = vpts, rast = ExDEM_crop)
IDW4_NN5_valid <- valid.diff(interpname = "IDW4_NN5", interprast = idw4_nn5, valid.pts = vpts, rast = ExDEM_crop)
SIKRIBES_valid <- valid.diff(interpname = "SIKRIBES", interprast = sikribes, valid.pts = vpts, rast = ExDEM_crop)
SIKRISPH_valid <- valid.diff(interpname = "SIKRISPH", interprast = sikrisph, valid.pts = vpts, rast = ExDEM_crop)
ORKRIBES_valid <- valid.diff(interpname = "ORKRIBES", interprast = orkribes, valid.pts = vpts, rast = ExDEM_crop)
ORKRISPH_valid <- valid.diff(interpname = "ORKRISPH", interprast = orkrisph, valid.pts = vpts, rast = ExDEM_crop)
TPS_valid <- valid.diff(interpname = "TPS", interprast = tps, valid.pts = vpts, rast = ExDEM_crop)
TPSTIN_valid <- valid.diff(interpname = "TPSTIN",interprast = tps_tin, valid.pts = vpts, rast = ExDEM_crop)

#Berechnung der Präzision
prec_IDW2 <- valid.prec(IDW2_valid$IDW2, tolmin = -0.2, tolmax = 0.2)
prec_IDW3 <- valid.prec(IDW3_valid$IDW3, tolmin = -0.2, tolmax = 0.2)
prec_IDW4 <- valid.prec(IDW4_valid$IDW4, tolmin = -0.2, tolmax = 0.2)
prec_NNI4 <- valid.prec(NNI4_valid$NNI4, tolmin = -0.2, tolmax = 0.2)
prec_NNI5 <- valid.prec(NNI5_valid$NNI5, tolmin = -0.2, tolmax = 0.2)
prec_NNI6 <- valid.prec(NNI6_valid$NNI6, tolmin = -0.2, tolmax = 0.2)
prec_IDW2NN5 <- valid.prec(IDW2_NN5_valid$IDW2_NN5, tolmin = -0.2, tolmax = 0.2)
prec_IDW3NN5 <- valid.prec(IDW3_NN5_valid$IDW3_NN5, tolmin = -0.2, tolmax = 0.2)
prec_IDW4NN5 <- valid.prec(IDW4_NN5_valid$IDW4_NN5, tolmin = -0.2, tolmax = 0.2)
prec_SIKRIBES <- valid.prec(SIKRIBES_valid$SIKRIBES, tolmin = -0.2, tolmax = 0.2)
prec_SIKRISPH <- valid.prec(SIKRISPH_valid$SIKRISPH, tolmin = -0.2, tolmax = 0.2)
prec_ORKRIBES <- valid.prec(ORKRIBES_valid$ORKRIBES, tolmin = -0.2, tolmax = 0.2)
prec_ORKRISPH <- valid.prec(ORKRISPH_valid$ORKRISPH, tolmin = -0.2, tolmax = 0.2)
prec_TPS <- valid.prec(TPS_valid$TPS, tolmin = -0.2, tolmax = 0.2)
prec_TPSTIN <- valid.prec(TPSTIN_valid$TPSTIN, tolmin = -0.2, tolmax = 0.2)


#Berechnung des Abweichungsmodells
IDW2_valmodel <- valid.model(pts= ExBP, interpname = "Inverse Distance Weighted (idp = 2)",diff_interp_rast = IDW2_valid, valid_value = IDW2_valid$IDW2, rast = ExDEM_crop)
IDW3_valmodel <- valid.model(pts= ExBP, interpname = "Inverse Distance Weighted (idp = 3)",diff_interp_rast = IDW3_valid, valid_value = IDW3_valid$IDW3, rast = ExDEM_crop)
IDW4_valmodel <- valid.model(pts= ExBP, interpname = "Inverse Distance Weighted (idp = 4)",diff_interp_rast = IDW4_valid, valid_value = IDW4_valid$IDW4, rast = ExDEM_crop)
NNI4_valmodel <- valid.model(pts= ExBP, interpname = "Nearest Neighbour (nmax = 4)",diff_interp_rast = NNI4_valid,valid_value = NNI4_valid$NNI4, rast = ExDEM_crop)
NNI5_valmodel <- valid.model(pts= ExBP, interpname = "Nearest Neighbour (nmax = 5)",diff_interp_rast = NNI5_valid,valid_value = NNI5_valid$NNI5, rast = ExDEM_crop)
NNI6_valmodel <- valid.model(pts= ExBP, interpname = "Nearest Neighbour (nmax = 6)",diff_interp_rast = NNI6_valid,valid_value = NNI6_valid$NNI6, rast = ExDEM_crop)
IDW2_NN5_valmodel <- valid.model(pts= ExBP, interpname = "Inverse Distance Weighted (idp = 2, nmax = 5)",diff_interp_rast = IDW2_NN5_valid,valid_value = IDW2_NN5_valid$IDW2_NN5, rast = ExDEM_crop)
IDW3_NN5_valmodel <- valid.model(pts= ExBP, interpname = "Inverse Distance Weighted (idp = 3, nmax = 5)",diff_interp_rast = IDW3_NN5_valid,valid_value = IDW3_NN5_valid$IDW3_NN5, rast = ExDEM_crop)
IDW4_NN5_valmodel <- valid.model(pts= ExBP, interpname = "Inverse Distance Weighted (idp = 4, nmax = 5",diff_interp_rast = IDW4_NN5_valid,valid_value = IDW4_valid$IDW4, rast = ExDEM_crop)
SIKRIBES_valmodel <- valid.model(pts= ExBP, interpname = "Simple Kriging (vgm = Bes)",diff_interp_rast = SIKRIBES_valid,valid_value = SIKRIBES_valid$SIKRIBES, rast = ExDEM_crop)
SIKRISPH_valmodel <- valid.model(pts= ExBP, interpname = "Simple Kriging (vgm = Sph)",diff_interp_rast = SIKRISPH_valid,valid_value = SIKRISPH_valid$SIKRISPH, rast = ExDEM_crop)
ORKRIBES_valmodel <- valid.model(pts= ExBP, interpname = "Ordinary Kriging (vgm = Bes)",diff_interp_rast = ORKRIBES_valid,valid_value = ORKRIBES_valid$ORKRIBES, rast = ExDEM_crop)
ORKRISPH_valmodel <- valid.model(pts= ExBP, interpname = "Ordinary Kriging (vgm = Sph)",diff_interp_rast = ORKRISPH_valid,valid_value = ORKRISPH_valid$ORKRISPH, rast = ExDEM_crop)
TPS_valmodel <- valid.model(pts= ExBP, interpname = "Thin Plated Spline",diff_interp_rast = TPS_valid,valid_value = TPS_valid$TPS, rast = ExDEM_crop)
TPSTIN_valmodel <- valid.model(pts= ExBP, interpname = "Thin Plated Spline (TIN)",diff_interp_rast = TPSTIN_valid,valid_value = TPSTIN_valid$TPSTIN, rast = ExDEM_crop)

#Aufrunden der Dezimalstellen für den Boxplot
IDW2_bxpl <- round_any(IDW2_valid$IDW2, .02)
IDW3_bxpl <-  round_any(IDW3_valid$IDW3, .02)
IDW4_bxpl <- round_any(IDW4_valid$IDW4, .02)
NNI3_bxpl <- round_any(NNI3_valid$NNI3, .02)
NNI4_bxpl <- round_any(NNI4_valid$NNI4, .02)
NNI5_bxpl <- round_any(NNI5_valid$NNI5, .02)
NNI6_bxpl <- round_any(NNI6_valid$NNI6, .02)
NNI7_bxpl <- round_any(NNI7_valid$NNI7, .02)
IDW2_NN5_bxpl <- round_any(IDW2_NN5_valid$IDW2_NN5, .02)
IDW3_NN5_bxpl <- round_any(IDW3_NN5_valid$IDW3_NN5, .02)
IDW4_NN5_bxpl <- round_any(IDW4_NN5_valid$IDW4_NN5, .02)
SIKRIBES_bxpl <- round_any(SIKRIBES_valid$SIKRIBES, .02)
SIKRISPH_bxpl <- round_any(SIKRISPH_valid$SIKRISPH, .02)
SIKRIGAU_bxpl <- round_any(SIKRIGAU_valid$SIKRIGAU, .02)
ORKRIBES_bxpl <- round_any(ORKRIBES_valid$ORKRIBES, .02)
ORKRISPH_bxpl <- round_any(ORKRISPH_valid$ORKRISPH, .02)
ORKRIGAU_bxpl <- round_any(ORKRIGAU_valid$ORKRIGAU, .02)
TPS_bxpl <- round_any(TPS_valid$TPS, .02)
TPSTIN_bxpl <- round_any(TPSTIN_valid$TPSTIN, .02)

#Berechnung der Boxplots
boxplot_1 <- cbind(IDW2_bxpl,
IDW3_bxpl,
IDW4_bxpl,
NNI4_bxpl,
NNI5_bxpl)

boxpplot_2 <- cbind(NNI6_bxpl,
               IDW2_NN5_bxpl,
               IDW3_NN5_bxpl,
               IDW4_NN5_bxpl,
               SIKRISPH_bxpl)

boxpplot_3 <- cbind(SIKRIBES_bxpl,
                    ORKRISPH_bxpl,
                    ORKRIBES_bxpl,
                    TPS_bxpl,
                    TPSTIN_bxpl)

colnames(boxplot_1) <- c("IDW2","IDW3","IDW4","NNI4","NNI5")

colnames(boxpplot_2) <- c("NNI6","IDW2NNI5","IDW3NNI5","IDW4NNI5","SIKRISPH")

colnames(boxpplot_3) <- c("SIKRIBES","ORKKRISPH","ORKRIBES","TPS","TPSTIN")

boxplot_1 <- reshape2::melt(boxplot_1,c("id","im"))

boxplot_1 <- data_frame(difference = boxplot_1$value, im = boxplot_1$im)

boxplot_gra_1 <- ggplot(boxplot_1, aes(x=difference, y=im))+
  geom_jitter(shape=3, width = 0.1, height = 0.1)+
  ggtitle("Deviation Boxplot 1")+
  xlab("difference in m")+
  ylab("interpolation method")+
  geom_boxplot()+
  coord_flip()+
stat_summary(fun=mean, geom="point", shape=23, size=4)
boxplot_gra_1
boxplot_2 <- reshape2::melt(boxpplot_2,c("id","im"))

boxplot_2 <- data_frame(difference = boxplot_2$value, im = boxplot_2$im)

boxplot_gra_2 <- ggplot(boxplot_2, aes(x=difference, y=im))+
  geom_jitter(shape=3, width = 0.1, height = 0.1)+
  ggtitle("Deviation Boxplot 2")+
  xlab("difference in m")+
  ylab("interpolation method")+
  geom_boxplot()+
  coord_flip()+
  stat_summary(fun=mean, geom="point", shape=23, size=4)
boxplot_gra_2

boxplot_3 <- reshape2::melt(boxpplot_3,c("id","im"))

boxplot_3 <- data_frame(difference = boxplot_3$value, im = boxplot_3$im)

boxplot_gra_3 <- ggplot(boxplot_3, aes(x=difference, y=im))+
  geom_jitter(shape=3, width = 0.1, height = 0.1)+
  ggtitle("Deviation Boxplot 3")+
  xlab("difference in m")+
  ylab("interpolation method")+
  geom_boxplot()+
  coord_flip()+
  stat_summary(fun=mean, geom="point", shape=23, size=4)
boxplot_gra_3
























12.4.	Berechnung von Akkumulationsbereichen des Wassers
#Berechnung des Topographic Classification Index (TCI) basierend auf dem interpolierten
#Höhenmodell

library(raster)
library(sf)

#Import des errechneten Höhenmodells
ngof <- raster("./derived/RASTER/NGOF_CS1.tif")
use_sp()

#installieren des Package " rgrass7", falls dieses noch nicht vorhanden ist
#BIVAND 2021, https://CRAN.R-project.org/package=rgrass7
#install.packages("rgrass7")
library(rgrass7)

#Initialisieren von GRASS-GIS
loc <- initGRASS("C:/Program Files/GRASS GIS 7.8", home = tempdir(), mapset = "PERMANENT", override = TRUE)

#Erstellen eines Projektes in GRASS-GIS
execGRASS(cmd ="g.proj",
          flags = c("c","quiet"),
          parameters = list(proj4 = as.character(crs(ngo))))

#Importieren des Rasters in die Arbeitsoberfläche von GRASS-GIS
writeRAST(x= as(ngof, "SpatialGridDataFrame"),
          vname = "dem",
          flags = c("overwrite","quiet"))

#Setzt die Grenzen der geographischen Region
execGRASS("g.region",
          parameters = list(raster="dem"),
          flags = "quiet")

execGRASS(cmd = "g.region",
           flags= c("p"))

#Berechnung hydrologischer Parameter, hier in diesem Beispiel wird der Topographic 
#Classification Index berechnet
execGRASS(cmd = "r.watershed",
          flags = c("b","quiet","overwrite"),
          parameters = list(elevation ="dem",
                            threshold = 500000,
                            tci = "tci1"))          
#Import des SpatialGridDataFrames in die Arbeitsoberfläche von R
tci <- readRAST(vname = "tci1")
#Konvertierung des SpatialGridDataFrames in ein Raster
tci<- raster::raster(tci, layer=1,values=TRUE)
#Export des Rasters als .tif Format
